initialize mu, phi and ro in edmonds   [done]

rename phiMap etc [done]

constructor function for VertexAssoc [done]

format lines [done]

replace string with bytestring DIMACSParser [done]

finish augment [done]

finish shrink [done]

test augment [done]

merge graph with State [done]

create a universal graph/state object [done]
    Graph
    Mu/Phi/Ro/Scanned
    Logger

build logger and integrate it with algorithm [done]

implement pathToRoot correctly [done]

augment malfunctioning [done]

test Util.isMatching/ Util.unique [done]

test and get algorithm to work on a couple of bipartite graphs [done]

incoparate the Edge we are working on into graph [done]

outsource logging functions from graph to logger [done]

banish logger: we will use trace from now on! [done]

get the algorithm to work on a non-bipartite graph (K3) [done]

fix bug: edges are not sorted, and the algorithm 
fails because of that. 
    Probably not that, rather shrink that doesnt work in general [done]

butterfly [done]

butterfly-extended [done]

make sure the edges in the matching exists in the graph [done]

bug: Maybe.fromJust in pma343
find another matching algorithm and 
test and see if we can reproduce the bug [done]
The bug seems to be with my algorithm

fix bug Maybe.fromJust: Nothing in shrink [done]

outsource debug functionality [done]

simplyfy expressions like (fun . AF.mu . forest) graph to: mu graph [done]

remove call to forward in Core.hs [done]

create a graph generator and try to generate a counterexample for 
a small k [done]
smallest counterexample found: 08/026.dmx

c++/026.dmx
8 9
3 5
2 4
2 5
2 6
1 5
6 7
3 7
0 1
0 5

card: 4
0 1             ==      1 2
2 4             ==      3 5
3 5             ==      4 6
6 7             ==      7 8

p edge 8 9
e 4 6 [x]
e 3 5 [x]
e 3 6 [ ]
e 3 7 [ ]
e 2 6 [ ]
e 7 8 [x]
e 4 8 [ ]
e 1 2 [x]
e 1 6 [ ]

1 6
3 7
4 8

* --- 1
|     |
2 --- 6 --- 4
      |     |
5 --- 3     |
      |     |
      7 --- 8


bug: lu980 result is 489 but should be 490 (fixed) [done]
make sure that the graph is exactly as specified by the file [done]

figure out how to run the code in TestMain [done]

check so that the number of vertices and edges are correct in DIMACSPARSER []

profiling []
    bottleneck: computing backward edges each iteration. Store them. [done]
    profile for fixed.dmx []

check if I can use Set instead of list.
    Problems arise in shrink and augment, where eg pathToRoot, odds, takeuntil
    is dependent on insertion order.

    Augment:
        pathToRoot: (px, py) does not need to be lists
                    (oddpx, oddpy) could potentially be retrieved by instead of
                    building sets of vertices, build sets of (Vertex, Bool),
                    where Bool represents odd or not.

                    One idea was to only store odds, but this does not work
                    since we need to check the intersection of the whole paths

