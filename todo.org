Todo file for edmonds-matching

* Done
** DONE initialize mu, phi and ro in edmonds
** DONE rename phiMap etc
** DONE constructor function for VertexAssoc
** DONE format lines
** DONE replace string with bytestring DIMACSParser
** DONE finish augment
** DONE finish shrink
** DONE test augment
** DONE merge graph with State
** DONE create a universal graph/state object
** DONE build logger and integrate it with algorithm
** DONE implement pathToRoot correctly
** DONE augment malfunctioning
** DONE test Util.isMatching/ Util.unique
** DONE test and get algorithm to work on a couple of bipartite graphs
** DONE incoparate the Edge we are working on into graph
** DONE outsource logging functions from graph to logger
** DONE banish logger: we will use trace from now on!
** DONE get the algorithm to work on a non-bipartite graph (K3)
** DONE fix bug: edges are not sorted, and the algorithm fails because of that. Probably not that, rather shrink that doesnt work in general 
** DONE butterfly
** DONE butterfly-extended
** DONE make sure the edges in the matching exists in the graph
** DONE bug: Maybe.fromJust in pma343
** DONE find other matching alg and test and see if we can reproduce the bug
** DONE fix bug Maybe.fromJust: Nothing in shrink
** DONE outsource debug functionality
** DONE simplyfy expressions like (fun . AF.mu . forest) graph to: mu graph
** DONE remove call to forward in Core.hs
** DONE create a graph generator and try to generate a counterexample for small k
** DONE smallest counterexample found: 08/026.dmx
** DONE bug: lu980 result is 489 but should be 490 (fixed)
** DONE make sure that the graph is exactly as specified by the file
** DONE figure out how to run the code in TestMain
** DONE check so that the number of vertices and edges are correct in DIMACSPARSER
** DONE profiling
** DONE check if I can use Set instead of list.

* TO-DO
** TODO Refactor Core.hs, especially shrink
** TODO transform graph into bipartite graph
** TODO merge functions in bipartite.core and genreal.core

Problems arise in shrink and augment, where eg pathToRoot, odds, takeuntil
is dependent on insertion order.
Augment:
pathToRoot: (px, py) does not need to be lists
	(oddpx, oddpy) could potentially be retrieved by instead of
	building sets of vertices, build sets of (Vertex, Bool),
	    where Bool represents odd or not.

	    One idea was to only store odds, but this does not work
	    since we need to check the intersection of the whole paths

While this would solve some things, there still comes a point where we
need to update the maps, and this is done knowing that the order of the
lists of vertices to update preserves the order. Sets doesn't preserve
the order of their elements.

r needs to be the first element in the intersection that satisfies the
predicate. If using sets, the order gets shuffeled, and so the aswer is
incorrect.

As treversing, build the intersection as a hashtable.
Finding ro(x) is done in constant time
quering ro(x) on the intersection is then done in constant time
** TODO Augment: I am generating p(x) and p(y)
